{"version":3,"file":"index.umd.mini.js","sources":["../hook.ts","../replace.ts"],"sourcesContent":["import {\n    MkFuncHook,\n    MkFuncHookErrorType,\n    MkFuncHookHandler,\n    MkFuncHookName,\n    MkFuncHookResult,\n    MkFuncHookState,\n} from \"@mpkit/types\";\n\n/**使用多种钩子钩住函数，并返回处理后的函数 */\nexport const hookFunc = (() => {\n    const isFunc = (item: any) =>\n        typeof item === \"function\" ||\n        (Array.isArray(item) &&\n            (item as any[]).some((it) => typeof it === \"function\"));\n    const hookNames = [\"before\", \"after\", \"catch\", \"complete\", \"done\"];\n    return <T extends Function = Function, S = any>(\n        func: T,\n        hooksInvariant: boolean,\n        hooks: MkFuncHook<S>[],\n        otherState?: any\n    ): MkFuncHookResult => {\n        let enabled: any = {\n            before: 1,\n            after: 1,\n            catch: 1,\n            complete: 1,\n            done: 1,\n        };\n        const has: any = {};\n\n        const hasHook = (name: MkFuncHookName): boolean => {\n            if (!hooksInvariant) {\n                // 如果hooks不是恒定的，则需要每次动态查询\n                return hooks.some((item) => item && isFunc(item[name]));\n            }\n            if (!(name in has)) {\n                hooks.forEach((item) => {\n                    if (!item) {\n                        return;\n                    }\n                    hookNames.forEach((n) => {\n                        if (isFunc(item[n])) {\n                            has[n] = 1;\n                        }\n                    });\n                });\n                hookNames.forEach((n) => {\n                    if (!(n in has)) {\n                        has[n] = 0;\n                    }\n                });\n            }\n            return has[name];\n        };\n        const targetFunc = (function MkFuncHelperOfHookTarget(...args) {\n            const ctx = this;\n            const state: MkFuncHookState<S> = {\n                ctx,\n                func,\n                args,\n                state: {} as S,\n                stepResultList: [],\n                doneCallback(err: Error, res?: any): any {\n                    if (state.done) {\n                        return;\n                    }\n                    if (err) {\n                        fireCatch(\"RejectReason\", err);\n                        state.fulfilled = false;\n                    } else {\n                        state.value = res;\n                        state.fulfilled = true;\n                    }\n                    fireHook(\"complete\");\n                    checkFireDone(\"callback\");\n                },\n            };\n            if (otherState) {\n                Object.assign(state.state, otherState);\n            }\n\n            const fireHook = (name: MkFuncHookName) => {\n                if (name !== \"done\" && name !== \"catch\" && state.stop) {\n                    return;\n                }\n                let needExec = !enabled[name]\n                    ? false\n                    : hooksInvariant\n                    ? hasHook(name)\n                    : true;\n                if (needExec) {\n                    try {\n                        for (let i = 0, len = hooks.length; i < len; i++) {\n                            const hook = hooks[i];\n                            if (hook && hook[name]) {\n                                if (Array.isArray(hook[name])) {\n                                    const list = hook[\n                                        name\n                                    ] as MkFuncHookHandler<S>[];\n                                    for (\n                                        let j = 0, lj = list.length;\n                                        j < lj;\n                                        j++\n                                    ) {\n                                        state.stepResultList.push({\n                                            step: name,\n                                            result: list[j]\n                                                ? list[j](state)\n                                                : undefined,\n                                        });\n                                        if (\n                                            name !== \"done\" &&\n                                            name !== \"catch\" &&\n                                            state.stop\n                                        ) {\n                                            break;\n                                        }\n                                    }\n                                } else {\n                                    state.stepResultList.push({\n                                        step: name,\n                                        result: (hook[\n                                            name\n                                        ] as MkFuncHookHandler<S>)(state),\n                                    });\n                                }\n                            }\n                            if (\n                                name !== \"done\" &&\n                                name !== \"catch\" &&\n                                state.stop\n                            ) {\n                                break;\n                            }\n                        }\n                    } catch (e) {\n                        const type = `${name[0].toUpperCase()}${name.substr(\n                            1\n                        )}Exception` as MkFuncHookErrorType;\n                        if (name !== \"catch\") {\n                            fireCatch(type, e);\n                        } else {\n                            state.errors.push({\n                                type,\n                                error: e,\n                            });\n                        }\n                    }\n                }\n            };\n            const fireCatch = (type: MkFuncHookErrorType, error) => {\n                if (!state.errors) {\n                    state.errors = [];\n                }\n                state.errors.push({\n                    type,\n                    error,\n                });\n                if (hasHook(\"catch\")) {\n                    try {\n                        fireHook(\"catch\");\n                    } catch (e) {\n                        state.errors.push({\n                            type: \"CatchException\",\n                            error: e,\n                        });\n                    }\n                }\n            };\n            const doneStep: any = {};\n            const checkFireDone = (step: string) => {\n                doneStep[step] = 1;\n                const isPromise =\n                    typeof state.result === \"object\" &&\n                    state.result &&\n                    (state.result.then || state.result.catch);\n                if (state.needDoneCallback && isPromise) {\n                    if (doneStep.promise && doneStep.callback) {\n                        state.done = true;\n                        fireHook(\"done\");\n                    }\n                } else {\n                    state.done = true;\n                    fireHook(\"done\");\n                }\n            };\n            fireHook(\"before\");\n            if (state.stop) {\n                fireHook(\"done\");\n                return state.result;\n            }\n            try {\n                const res = func.apply(ctx, args);\n                state.result = res;\n                fireHook(\"after\");\n                const isPromise =\n                    typeof state.result === \"object\" &&\n                    state.result &&\n                    (state.result.then || state.result.catch);\n                if (state.needDoneCallback || isPromise) {\n                    if (isPromise && state.result.then) {\n                        state.result.then((value) => {\n                            state.value = value;\n                            state.fulfilled = true;\n                            fireHook(\"complete\");\n                            checkFireDone(\"promise\");\n                        });\n                    }\n                    if (isPromise && state.result.catch) {\n                        state.result.catch((e) => {\n                            state.fulfilled = false;\n                            fireCatch(\"RejectReason\", e);\n                            fireHook(\"complete\");\n                            checkFireDone(\"promise\");\n                        });\n                    }\n                } else {\n                    fireHook(\"done\");\n                }\n                return state.result;\n            } catch (e) {\n                fireCatch(\"MethodException\", e);\n                fireHook(\"done\");\n                throw e;\n            }\n        } as unknown) as T;\n        return {\n            func: targetFunc,\n            disable(name?: MkFuncHookName) {\n                if (name) {\n                    enabled[name] = 0;\n                } else {\n                    hookNames.forEach((n) => {\n                        enabled[n] = 0;\n                    });\n                }\n            },\n            enable(name?: MkFuncHookName) {\n                if (name) {\n                    enabled[name] = 1;\n                } else {\n                    hookNames.forEach((n) => {\n                        enabled[n] = 1;\n                    });\n                }\n            },\n        };\n    };\n})();\n","import { MkReplaceFuncCallback } from \"@mpkit/types\";\n\nexport function replaceFunc<T extends Function = Function>(\n    original: T,\n    replacer: T,\n    callback?: MkReplaceFuncCallback,\n    data?: any\n): T {\n    let isReplace = true;\n    callback &&\n        callback({\n            data,\n            original,\n            replace() {\n                isReplace = true;\n            },\n            restore() {\n                isReplace = false;\n            },\n        });\n    return (function (...args) {\n        if (isReplace) {\n            return replacer.apply(this, args);\n        } else {\n            return original.apply(this, args);\n        }\n    } as unknown) as T;\n}\n"],"names":["hookNames","hookFunc","func","hooksInvariant","hooks","otherState","hasHook","name","has","forEach","item","n","isFunc","some","enabled","before","after","complete","done","_i","args","state","ctx","this","stepResultList","doneCallback","err","res","fireCatch","fulfilled","value","fireHook","checkFireDone","Object","assign","stop","i","len","length","hook","Array","isArray","list","j","lj","push","step","result","undefined","e","type","toUpperCase","substr","errors","error","doneStep","isPromise","_typeof","then","needDoneCallback","promise","callback","apply","disable","enable","it","original","replacer","data","isReplace","replace","restore"],"mappings":"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"}