{"version":3,"sources":["index.cjs.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/*!\n* MpKit v1.1.1\n* (c) 2020-2021 imingyu<mingyuhisoft@163.com>\n* Released under the MIT License.\n* Github: https://github.com/imingyu/mpkit/tree/master/packages/func-helper\n*/\n\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction replaceFunc(original, replacer, callback, data) {\n  var isReplace = true;\n  callback && callback({\n    data: data,\n    original: original,\n    replace: function replace() {\n      isReplace = true;\n    },\n    restore: function restore() {\n      isReplace = false;\n    }\n  });\n  return function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    if (isReplace) {\n      return replacer.apply(this, args);\n    } else {\n      return original.apply(this, args);\n    }\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\n/**使用多种钩子钩住函数，并返回处理后的函数 */\nvar hookFunc = function () {\n  var isFunc = function isFunc(item) {\n    return typeof item === \"function\" || Array.isArray(item) && item.some(function (it) {\n      return typeof it === \"function\";\n    });\n  };\n\n  var hookNames = [\"before\", \"after\", \"catch\", \"complete\", \"done\"];\n  return function (func, hooksInvariant, hooks, otherState) {\n    var enabled = {\n      before: 1,\n      after: 1,\n      \"catch\": 1,\n      complete: 1,\n      done: 1\n    };\n    var has = {};\n\n    var hasHook = function hasHook(name) {\n      if (!hooksInvariant) {\n        // 如果hooks不是恒定的，则需要每次动态查询\n        return hooks.some(function (item) {\n          return item && isFunc(item[name]);\n        });\n      }\n\n      if (!(name in has)) {\n        hooks.forEach(function (item) {\n          if (!item) {\n            return;\n          }\n\n          hookNames.forEach(function (n) {\n            if (isFunc(item[n])) {\n              has[n] = 1;\n            }\n          });\n        });\n        hookNames.forEach(function (n) {\n          if (!(n in has)) {\n            has[n] = 0;\n          }\n        });\n      }\n\n      return has[name];\n    };\n\n    var targetFunc = function MkFuncHelperOfHookTarget() {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var ctx = this;\n      var state = {\n        ctx: ctx,\n        func: func,\n        args: args,\n        state: {},\n        stepResultList: [],\n        doneCallback: function doneCallback(err, res) {\n          if (state.done) {\n            return;\n          }\n\n          if (err) {\n            fireCatch(\"RejectReason\", err);\n            state.fulfilled = false;\n          } else {\n            state.value = res;\n            state.fulfilled = true;\n          }\n\n          fireHook(\"complete\");\n          checkFireDone(\"callback\");\n        }\n      };\n\n      if (otherState) {\n        Object.assign(state.state, otherState);\n      }\n\n      var fireHook = function fireHook(name) {\n        if (name !== \"done\" && name !== \"catch\" && state.stop) {\n          return;\n        }\n\n        var needExec = !enabled[name] ? false : hooksInvariant ? hasHook(name) : true;\n\n        if (needExec) {\n          try {\n            for (var i = 0, len = hooks.length; i < len; i++) {\n              var hook = hooks[i];\n\n              if (hook && hook[name]) {\n                if (Array.isArray(hook[name])) {\n                  var list = hook[name];\n\n                  for (var j = 0, lj = list.length; j < lj; j++) {\n                    state.stepResultList.push({\n                      step: name,\n                      result: list[j] ? list[j](state) : undefined\n                    });\n\n                    if (name !== \"done\" && name !== \"catch\" && state.stop) {\n                      break;\n                    }\n                  }\n                } else {\n                  state.stepResultList.push({\n                    step: name,\n                    result: hook[name](state)\n                  });\n                }\n              }\n\n              if (name !== \"done\" && name !== \"catch\" && state.stop) {\n                break;\n              }\n            }\n          } catch (e) {\n            var type = \"\" + name[0].toUpperCase() + name.substr(1) + \"Exception\";\n\n            if (name !== \"catch\") {\n              fireCatch(type, e);\n            } else {\n              state.errors.push({\n                type: type,\n                error: e\n              });\n            }\n          }\n        }\n      };\n\n      var fireCatch = function fireCatch(type, error) {\n        if (!state.errors) {\n          state.errors = [];\n        }\n\n        state.errors.push({\n          type: type,\n          error: error\n        });\n\n        if (hasHook(\"catch\")) {\n          try {\n            fireHook(\"catch\");\n          } catch (e) {\n            state.errors.push({\n              type: \"CatchException\",\n              error: e\n            });\n          }\n        }\n      };\n\n      var doneStep = {};\n\n      var checkFireDone = function checkFireDone(step) {\n        doneStep[step] = 1;\n        var isPromise = _typeof(state.result) === \"object\" && state.result && (state.result.then || state.result[\"catch\"]);\n\n        if (state.needDoneCallback && isPromise) {\n          if (doneStep.promise && doneStep.callback) {\n            state.done = true;\n            fireHook(\"done\");\n          }\n        } else {\n          state.done = true;\n          fireHook(\"done\");\n        }\n      };\n\n      fireHook(\"before\");\n\n      if (state.stop) {\n        fireHook(\"done\");\n        return state.result;\n      }\n\n      try {\n        var res = func.apply(ctx, args);\n        state.result = res;\n        fireHook(\"after\");\n        var isPromise = _typeof(state.result) === \"object\" && state.result && (state.result.then || state.result[\"catch\"]);\n\n        if (state.needDoneCallback || isPromise) {\n          if (isPromise && state.result.then) {\n            state.result.then(function (value) {\n              state.value = value;\n              state.fulfilled = true;\n              fireHook(\"complete\");\n              checkFireDone(\"promise\");\n            });\n          }\n\n          if (isPromise && state.result[\"catch\"]) {\n            state.result[\"catch\"](function (e) {\n              state.fulfilled = false;\n              fireCatch(\"RejectReason\", e);\n              fireHook(\"complete\");\n              checkFireDone(\"promise\");\n            });\n          }\n        } else {\n          fireHook(\"done\");\n        }\n\n        return state.result;\n      } catch (e) {\n        fireCatch(\"MethodException\", e);\n        fireHook(\"done\");\n        throw e;\n      }\n    };\n\n    return {\n      func: targetFunc,\n      disable: function disable(name) {\n        if (name) {\n          enabled[name] = 0;\n        } else {\n          hookNames.forEach(function (n) {\n            enabled[n] = 0;\n          });\n        }\n      },\n      enable: function enable(name) {\n        if (name) {\n          enabled[name] = 1;\n        } else {\n          hookNames.forEach(function (n) {\n            enabled[n] = 1;\n          });\n        }\n      }\n    };\n  };\n}();\n\nexports.hookFunc = hookFunc;\nexports.replaceFunc = replaceFunc;\n//# sourceMappingURL=index.cjs.js.map\n"]}